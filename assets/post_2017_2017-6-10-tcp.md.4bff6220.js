import{o as e,c as r,f as a}from"./app.5f3fb606.js";const t='{"title":"TCP协议之握手","description":"","frontmatter":{"title":"TCP协议之握手","tag":["TCP"],"author":"Artiely","date":"2017-6-10","cover":"https://gitee.com/artiely/Figure-bed/raw/master/images/20200315172358.png","base64":"fefcfd"},"headers":[{"level":2,"title":"三次握手Three-way Handshake","slug":"三次握手three-way-handshake"},{"level":2,"title":"四次握手Four-way Handshake","slug":"四次握手four-way-handshake"},{"level":2,"title":"【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？","slug":"问题1为什么连接的时候是三次握手关闭的时候却是四次握手"},{"level":2,"title":"【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？","slug":"问题2为什么time_wait状态需要经过2msl最大报文段生存时间才能返回到close状态"}],"relativePath":"post/2017/2017-6-10-tcp.md","lastUpdated":1629109029506}',l={},h=a('<h1 id="tcp协议之握手"><a class="header-anchor" href="#tcp协议之握手" aria-hidden="true">#</a> TCP协议之握手</h1><p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义</p><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手</p><h2 id="三次握手three-way-handshake"><a class="header-anchor" href="#三次握手three-way-handshake" aria-hidden="true">#</a> 三次握手Three-way Handshake</h2><p>首先Client端发送连接请求报文，Server端接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p><blockquote><p>SYN（synchronous）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。<br> ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。<br> 在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。</p></blockquote><h2 id="四次握手four-way-handshake"><a class="header-anchor" href="#四次握手four-way-handshake" aria-hidden="true">#</a> 四次握手Four-way Handshake</h2><blockquote><p>【注意】中断连接端可以是Client端，也可以是Server端。<br> 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，&quot;就知道可以断开连接了&quot;。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！<br> 在TIME_WAIT状态中，如果TCP client端最后一次发送的ACK丢失了，它将重新发送。TIME_WAIT状态中所需要的时间是依赖于实现方法的。典型的值为30秒、1分钟和2分钟。等待之后连接正式关闭，并且所有的资源(包括端口号)都被释放。</p></blockquote><h2 id="问题1为什么连接的时候是三次握手关闭的时候却是四次握手"><a class="header-anchor" href="#问题1为什么连接的时候是三次握手关闭的时候却是四次握手" aria-hidden="true">#</a> 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？</h2><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&quot;你发的FIN报文我收到了&quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><h2 id="问题2为什么time_wait状态需要经过2msl最大报文段生存时间才能返回到close状态"><a class="header-anchor" href="#问题2为什么time_wait状态需要经过2msl最大报文段生存时间才能返回到close状态" aria-hidden="true">#</a> 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h2><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>',12);l.render=function(a,t,l,i,o,C){return e(),r("div",null,[h])};export default l;export{t as __pageData};
