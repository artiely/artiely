import{o as e,c as s,f as a}from"./app.5f3fb606.js";const i='{"title":"前端并发性能优化","description":"","frontmatter":{"title":"前端并发性能优化","tag":["javaScript"],"cover":"https://gitee.com/artiely/Figure-bed/raw/master/image/20200903202227.png","base64":"0a1a4a","author":"artiely","date":"2020-9-3"},"headers":[{"level":2,"title":"cookie free","slug":"cookie-free"},{"level":2,"title":"域名发散 domain hash","slug":"域名发散-domain-hash"},{"level":2,"title":"雪碧图 （图片合并）css sprites","slug":"雪碧图-图片合并css-sprites"},{"level":2,"title":"代码压缩 js/css combine","slug":"代码压缩-jscss-combine"},{"level":2,"title":"缓存","slug":"缓存"},{"level":2,"title":"按需加载（懒加载）","slug":"按需加载懒加载"}],"relativePath":"post/2020/2020-9-3-brower.md","lastUpdated":1629110865375}',r={},o=a('<blockquote><p>前端技术的逐渐成熟，还衍生了domain hash, cookie free, css sprites, js/css combine, max expires time, loading images on demand等等技术。这些技术的出现和大量使用都和并发资源数有关。</p></blockquote><h2 id="cookie-free"><a class="header-anchor" href="#cookie-free" aria-hidden="true">#</a> cookie free</h2><p>按照普通设计，当网站cookie信息有1 KB、网站首页共150个资源时，用户在请求过程中需要发送150 KB的cookie信息，在512 Kbps的常见上行带宽下，需要长达3秒左右才能全部发送完毕。 尽管这个过程可以和页面下载不同资源的时间并发，但毕竟对速度造成了影响。 而且这些信息在js/css/images/flash等静态资源上，几乎是没有任何必要的。 解决方案是启用和主站不同的域名来放置静态资源，也就是cookie free。</p><h2 id="域名发散-domain-hash"><a class="header-anchor" href="#域名发散-domain-hash" aria-hidden="true">#</a> 域名发散 domain hash</h2><p>将css放置在页面最上方应该是很自然的习惯，但第一个css内引入的图片下载是有可能堵塞后续的其他js的下载的。而在目前普遍过百的整页请求数的前提下，浏览器提供的仅仅数个并发，对于进行了良好优化甚至是前面有CDN的系统而言，是极大的性能瓶颈。 这也就衍生了domain hash技术来使用多个域名加大并发量（因为浏览器是基于domain的并发控制，而不是page），不过过多的散布会导致DNS解析上付出额外的代价，所以一般也是控制在2-4之间。 这里常见的一个性能小坑是没有机制去确保URL的哈希一致性（即同一个静态资源应该被哈希到同一个域名下），而导致资源被多次下载。</p><h2 id="雪碧图-图片合并css-sprites"><a class="header-anchor" href="#雪碧图-图片合并css-sprites" aria-hidden="true">#</a> 雪碧图 （图片合并）css sprites</h2><p>再怎么提速，页面上过百的总资源数也仍然是很可观的，如果能将其中一些很多页面都用到的元素如常用元素如按钮、导航、Tab等的背景图，指示图标等等合并为一张大图，并利用css background的定位来使多个样式引用同一张图片，那也就可以大大的减少总请求数了，这就是css sprites的由来。</p><h2 id="代码压缩-jscss-combine"><a class="header-anchor" href="#代码压缩-jscss-combine" aria-hidden="true">#</a> 代码压缩 js/css combine</h2><p>全站的js/css原本并不多，其合并技术的产生却是有着和图片不同的考虑。 由于cs/js通常可能对dom布局甚至是内容造成影响，在浏览器解析上，不连贯的载入是会造成多次重新渲染的。因此，在网站变大需要保持模块化来提高可维护性的前提下，js/css combine也就自然衍生了，同时也是minify、compress等对内容进行多余空格、空行、注释的整理和压缩的技术出现的原因。</p><h2 id="缓存"><a class="header-anchor" href="#缓存" aria-hidden="true">#</a> 缓存</h2><p>随着cookie free和domain hash的引入，网站整体的打开速度将会大大的上一个台阶。 这时我们通常看到的问题是大量的请求由于全站公有header/footer/nav等关系，其对应文件早已在本地缓存里存在了，但为了确保这个内容没有发生修改，浏览器还是需要请求一次服务器，拿到一个304 Not Modified才能放心。 一些比较大型的网站在建立了比较规范的发布制度后，会将大部分静态资源的有效期设置为最长，也就是Cache-Control max-age为10年。 这样设置后，浏览器就再也不会在有缓存的前提下去确认文件是否有修改了。 超长的有效期可以让用户在访问曾访问过的网站或网页时，获得最佳的体验。 带来的复杂性则体现在每次对静态资源进行更新时，必须发布为不同的URL来确保用户重新加载变动的资源。</p><h2 id="按需加载懒加载"><a class="header-anchor" href="#按需加载懒加载" aria-hidden="true">#</a> 按需加载（懒加载）</h2><p>即使是这样做完，仍然还存在着一个很大的优化空间，那就是很多页面浏览量很大，但其实用户直接很大比例直接就跳走了，第一屏以下的内容用户根本就不感兴趣。 对于超大流量的网站如淘宝、新浪等，这个问题尤其重要。 这个时候一般是通过将图片的src标签设置为一个loading或空白的样式，在用户翻页将图片放入可见区或即将放入可见区时再去载入。 不过这个优化其实和并发资源数的关系就比较小了，只是对一些散布不合理，或第一页底部的资源会有一定的帮助。 主要意图还是降低带宽费用。</p>',13);r.render=function(a,i,r,c,t,h){return e(),s("div",null,[o])};export default r;export{i as __pageData};
